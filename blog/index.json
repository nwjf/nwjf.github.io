[{"content":"关于我\n英文名: newwjf 职业: 程序员 运动: 跑步、乒乓球、爬山、游泳 博客源码: https://github.com/nwjf/blog 博客地址: https://nwjf.github.io ","permalink":"https://xyming108.github.io/about/","summary":"关于我 英文名: newwjf 职业: 程序员 运动: 跑步、乒乓球、爬山、游泳 博客源码: https://github.com/nwjf/blog 博客地址: https://nwjf.github.io","title":"🙋🏻‍♂️关于"},{"content":" 👉友链格式 名称： nwjf Blog 网址： 图标： 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://xyming108.github.io/links/","summary":"👉友链格式 名称： nwjf Blog 网址： 图标： 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内","title":"🤝友链"},{"content":"vue数据是双向绑定对开发者带来了不少的便利， 而父子组件之间的通信却是单向数据流，\nv-model命令 v-model是Vue用于表单元素上创建双向数据绑定，它本质是一个语法糖，在单向数据绑定的基础上，增加了监听用户输入事件并更新数据的功能\nv-model命令 是v-bind:value和v-on:input的结合\n用v-bind,和v-on实现v-model\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input :value=\u0026#34;value\u0026#34; @input=\u0026#34;value = $event.target.value\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;test\u0026#39;, data() { return { value: \u0026#39;\u0026#39; } } } \u0026lt;/script\u0026gt; 简单的input的双向数据绑定(v-model)\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 姓名： \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入姓名\u0026#34; v-model=\u0026#34;name\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;Test\u0026#39; data() { return { name: \u0026#39;\u0026#39; } } } \u0026lt;/script\u0026gt; 单向数据流 vue的数据是双向绑定，为什么父子组件之间却是单向数据流？\n所有状态的改变可记录、可跟踪，源头易追溯; 所有数据只有一份，组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性; 父子组件之间的通信 vue组件之间使用单向数据绑定的模式实现组件之间的通信\n单向数据流模式\n\u0026lt;!-- 父组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;children :name=\u0026#34;name\u0026#34; @sub-input=\u0026#34;subInput\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Children from \u0026#39;./Children\u0026#39;; export default { name: \u0026#39;Parent\u0026#39;, components: { Children }, data() { return { name: \u0026#39;\u0026#39; } }, methods: { subInput(val) { this.name = val; } } } \u0026lt;/script\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;value\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Children from \u0026#39;./Children\u0026#39;; export default { name: \u0026#39;Children\u0026#39;, props: [\u0026#39;name\u0026#39;], data() { return { value: \u0026#39;\u0026#39; } }, watch: { value(val) { this.$emit(\u0026#39;subInput\u0026#39;, val) } } } \u0026lt;/script\u0026gt; 在vue中是不允许我们修改props中的数据的， 在子组件中只能通过事件的方式向父组件传递参数\n这种在我们自定义一个简单的input输入组件的时候却是很麻烦，\n实现一个组件之间的v-model语法糖\n\u0026lt;!-- 父组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 父组件输入框 \u0026lt;input v-model=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;!-- 引用子组件 --\u0026gt; \u0026lt;my-input v-model=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import MyInput from \u0026#39;./MyInput\u0026#39;; export default { name: \u0026#39;Parent\u0026#39;, components: { MyInput }, data() { return { name: \u0026#39;\u0026#39; } } } \u0026lt;/script\u0026gt; \u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;myName\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;MyInput\u0026#39;, props: [\u0026#39;value\u0026#39;], // 这里一定要使用value data() { name: \u0026#39;\u0026#39; }, watch: { name(val) { this.$emit(\u0026#39;input\u0026#39;, val); }, value(val) { this.name = val; } } } \u0026lt;/script\u0026gt; ","permalink":"https://xyming108.github.io/posts/vue-7/","summary":"vue数据是双向绑定对开发者带来了不少的便利， 而父子组件之间的通信却是单向数据流， v-model命令 v-model是Vue用于表单元素上创建双向数据绑定，它本质是一个语法糖，在单向数据绑定的基础上，增加了监听用户输入事件并更新数据的功能 v-model命令 是v-bind:value","title":"Vue(六) -- v-model"},{"content":"前言 随着TypeScript 的不断发展，越来越多的开发者认可并使用TypeScript开发应用。 本文的目标是使TypeScript新特性的代码风格保持一致。 由于TypeScript依然在快速发展，也随时保持更新。 最新更新时间2019-6-11\n项目规范 项目必须有 README.md 描述文件 项目描述 引用技术描述 代码风格描述 目录结构 运行环境 开发命令，运行命令，以及其他命令 复杂流程介绍等 环境 TypeScript 文件使用.ts拓展名。含JSX语法的TypeScript 文件使用 .tsx扩展名。 tsconfig.json 配置文件应开启 script, noImplicitReturns, noUnusedLocals 选项（建议） tsconfig.json 配置文件应开启 allowSyntheticDefaultImports 选项（建议） // good import React, {PureComponent} from \u0026#39;react\u0026#39;; // bad import * as React from \u0026#39;react\u0026#39;; 文件 在文件结尾处保留一个空行。 命名 接口 使用 Pascal 命名法 接口名 不使用 I 作为前缀。 // good interface ButtonProps {} // bad interface IButtonProps {} 特性 使用const 声明 枚举 // good const enum Directions { UP, DOWN } // bad enum Directions { UP, DOWN } 类型 使用string / number / boolean 声明基本类型，不使用 String / Number / Boolean。 // good let str: string; // bad let str: String; 不使用 Object / Function 声明类型。 数组元素为简单类型（非匿名且不含泛型）时，使用T[]声明类型，否则应使用Array。 数组元素为不可变数据时，使用 ReadonlyArray 声明类型 // good let files: string[]; let array: Array\u0026lt;string | number\u0026gt;; let buffer: Buffer[]; let responses: Array\u0026lt;Promise\u0026lt;number\u0026gt;\u0026gt;; // bad let files: Array\u0026lt;string\u0026gt;; let array: (string | number)[]; let buffer: Array\u0026lt;Buffer\u0026gt; let responses: Promise\u0026lt;number\u0026gt;[]; 不使用 ！声明对象属性非空 // good if (foo.bar \u0026amp;\u0026amp; foo.bar.baz) {} // bad if (foo!.bar!.baz) {} 使用 as 进行类型声明和转换，不适用\u0026lt;\u0026gt; // good const root = document.getElementById(\u0026#39;root\u0026#39;) as HTMLDivElement; // bad const root = \u0026lt;HTMLDivElement\u0026gt;document.getElementById(\u0026#39;root\u0026#39;); 接口不应为空 接口中同一函数重载的类型声明需相邻 // good interface AnyInterface { foo(); foo(x: string); bar(); bar(x: string); } // bad interface AnyInterface { foo(); bar(); foo(x: string); bar(x: string); } 使用 === !=判断，不使用 == != // good if (foo !== null \u0026amp;\u0026amp; foo !== undefined) {} // bad if (foo != null) {} 使用 \u0026hellip; 将类数组对象转换为数组，不使用Array.form / Array.prototype.slice // good const element = [...document.querySelectorAll(\u0026#39;.foo\u0026#39;)]; // bad const element = Array.from(document.querySelectorAll(\u0026#39;.foo\u0026#39;)); // worst const element = Array.prototype.slice.call(document.querySelectorAll(\u0026#39;.foo\u0026#39;)); ","permalink":"https://xyming108.github.io/posts/tscodespecification/","summary":"前言 随着TypeScript 的不断发展，越来越多的开发者认可并使用TypeScript开发应用。 本文的目标是使TypeScript新特性的代码风格保持一致。 由于TypeScript依然在快速发展，也随时保持更新。 最新更新时间2019-6-11 项目规范 项目必须有 README.md 描述文件 项目描述 引","title":"TypeScript开发规范"},{"content":"前言 本文档的目标是JavaScript代码风格保持一致，容易被理解和被维护。\n项目规范 项目必须有 README.md 描述文件 项目描述 引用技术描述 代码风格描述 目录结构 运行环境 开发命令，运行命令，以及其他命令 复杂流程介绍等 代码风格 建议JavaScript使用无BOM的UTF-8编码 建议在文件结尾处保留一个空格 使用4个空格作为一个缩进层级，不允许使用2个空格或者tab字符 switch下的case和default必须增加一个缩进 // good switch () { case \u0026#39;1\u0026#39;: break; default: break; } 代码空格 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格 // good var a = !arr.length; a++; ++a; a = b + c; // bad var a=!arr.length; a=b+c; 用作代码块起始的左花括号 { 前必须有一个空格 if / else / else if / for / while / function / switch / do / try / catch / finally 关键字后，必须有一个空格 // good if () {} (function () {})(); while () {} // bad if(){} (function(){})() 在对象创建时，属性中的 ： 之后必须有一个空格， ： 之前不允许有空格 // good var obj = { a: 1, b: 1 }; // bad var obj = { a:1, // bad b : 1, // bad c :1 // bad }; 在函数声明，具名函数表达式，函数调用中，函数名和 （ 之间不允许有空格 // good function funName() {} var funName = function funName2() {} // bad function funName () {} , 和 ; 前不允许有空格，如果不位于行尾， , 和 ; 后必须跟一个空格 // good callback(a, b); // bad callback(a , b) ; 在函数调用，函数声明，括号表达式，属性访问， if / for / while / switch / catch 等语句中，() [] 内紧贴括号部分不允许有空格 // good callback(params1, params2, params3); list(this.data[this.arr[i]]); if (length \u0026gt; arr.length) {} // bad callback( params1, params2, params3 ); list( this.data[ this.arr[ i ] ] ); if ( length \u0026gt; arr.length ) {} 单行声明的数组与对象，如果包含元素， {}, [] 内紧贴括号部分不允许包含空格 声明包含元素的数组与对象，只有当内部元素的形式比较简单时，才允许写在一行，元素复杂的情况，应该换行书写。 在函数声明，函数表达式，函数调用，对象创建，数组创建， for语句等场景中，不允许在 , ;前换行。 // good var arr = []; var arr = [1, 2, 3]; var obj = {}; var obj = {a: \u0026#39;1\u0026#39;, b: \u0026#39;j\u0026#39;}; var obj = { name: \u0026#39;obj\u0026#39;, sex: 1, age: 1 }; // bad var arr = [ ]; var arr = [ 1, 2, 3 ]; var obj = { }; var obj = { a: \u0026#39;1\u0026#39;, b: \u0026#39;2\u0026#39; }; var obj = {name: \u0026#39;obj\u0026#39;, sex: 1, age: 1}; var obj = { name: \u0026#39;obj\u0026#39; , sex: 1 }; import语句中{}内侧紧贴括号部分不允许有空格 // good import {mapGetters, mapState} from \u0026#39;vuex\u0026#39;; // bad import { mapGetters, mapState } from \u0026#39;vuex\u0026#39;; 行尾不得有空格 每个独立语句结束后必须换行 每行不得超过120个字符 超长的不可分割的代码允许例外，比如复杂的正则表达式，长字符串不例外 运算符处换行时，运算符必须在新行的行首 // good var isTrue = user.isTrue \u0026amp;\u0026amp; info.isTrue \u0026amp;\u0026amp; content.isTrue || info.length; var result = num1 + num2 + num3 + num4; var html = \u0026#39;\u0026#39; + \u0026#39;\u0026lt;div\u0026gt;\u0026#39; + \u0026#39;\u0026lt;div\u0026gt;\u0026#39; + \u0026#39;\u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt;\u0026#39; + \u0026#39;\u0026lt;/div\u0026gt;\u0026#39; + \u0026#39;\u0026lt;/div\u0026gt;\u0026#39;; var html = [ \u0026#39;\u0026lt;div\u0026gt;\u0026#39;, \u0026#39;\u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt;\u0026#39;, \u0026#39;\u0026lt;/div\u0026gt; ].join(\u0026#39;\u0026#39;); 当函数调用时，如果有一个或以上参数跨越多行，应当每一个参数独立一样。 这通常出现在匿名函数或者对象初始化作为参数时，如setTimeout等 // good setTimeout( function () { console.log(\u0026#39;setTimeout\u0026#39;); }, 300 ); // bad setTimeout(function() { console.log(\u0026#39;setTimeout\u0026#39;); }, 1000); 链式操作\n链式调用较长时采用缩进进行调整 三元运算符由三部分组成，因此其换行应当对于每个部分的长度不同，形成不同的情况 // good $(\u0026#39;#item) .find(\u0026#39;.select\u0026#39;) .eq(1) .end(); var result = isTrue ? resultA : resultB; // 数组和对象初始化调用，严格按照每个对象的{}在独立一行的书写风格 var array = [ {}, {} ]; var array = [ { // code }, { // code } ]; 代码分号 不得省略语句结束的分号 在if /else / for / do / while语句中，即使只有一行，也不得省略{} 函数定义结束不允许添加分号 // good var name = \u0026#39;\u0026#39;; if (true) { name = \u0026#39;\u0026#39;; } function test() {} // bad var name = \u0026#39;\u0026#39; if (true) name = \u0026#39;\u0026#39;; function test() {}; 命名 变量 使用 camel 命名法 常量 使用 全部字母大写，单词间下划线分割 命名法 函数 使用 Camel 命名法 类 使用 Pascal 命名法 函数参数 使用 Camel 命名法 类方法属性 使用 Camel 命名法 类名 使用名词 函数名 使用动宾短语 boolean类型变量使用is或has开头 变量，函数在使用前必须先定义 每个var，let，const建议只定义一个变量 // good let userName = \u0026#39;\u0026#39;; let isTrue = true; const PI = 3.14; const USER_NAME = \u0026#39;\u0026#39;; function getStyle() {} class Test {} // good var name = \u0026#39;\u0026#39; // bad name = \u0026#39;\u0026#39;; 尽量使用 ===，!==，不适用== ，!=，仅当判断null或undefined时允许使用==null 循环 不要在循环体中包含函数表达式，事先将函数提取到循环体外。 对有序集合遍历时，缓存length 虽然浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次length访问时会动态计算元素个数，此时缓存length能有效提高程序性能 // good for (var i = 0, len = elements.length; i \u0026lt; len; i++) { } 类型 类型检测 类型检测优先使用typeof。对象类型检测使用instanceof。 null或undefined使用==null typeof variable === \u0026#39;string\u0026#39;; // string typeof variable === \u0026#39;number\u0026#39;; // number typeof variable === \u0026#39;boolean\u0026#39;; // boolean typeof variable === \u0026#39;function\u0026#39;; // Function typeof variable === \u0026#39;object\u0026#39;; // Object variable instanceof RegExp; // RegExp; variable instanceof Array; // Array variable === null; // null variable === \u0026#39;undefined\u0026#39;; // undefined; variable == null; // null or undefined; 类型转换 转换为string时，使用+\u0026rsquo;\u0026rsquo;。 // good num + \u0026#39;\u0026#39;; 转换为number时，通常使用+。 // good +str; // bad Number(str); string 转换为 number ，要转换的字符串结尾包含非数字并期望忽略时，使用 parseInt。 使用 parseInt 时，必须制定进制 // good var width = \u0026#39;200px\u0026#39;; parseInt(width, 10); // bad parseInt(width); number 去除小数点， 使用Math.floor / Math.round / Math.ceil，不使用 parseInt // good var num = 3.14; Math.ceil(num); // bad parseInt(num, 10); 闭包 建议在适当的时候将闭包内大对象设置为null\n在JavaScript中，无需特别的关键词就可以使用闭包，一个函数可以任意访问在其定义的作用域外的变量。需要注意的时，函数的作用域时静态的，即在定义时决定，与调用的时机和方式没有任何关系。 闭包会阻止一些变量的垃圾回收，对于较老旧的JavaScript引擎，可能导致外部所有变量均无法回收。\n以下内容会影响到闭包内变量的回收：\n嵌套的函数中是否有使用的变量 嵌套的函数中是否有 直接调用eval 是否使用with表达式 Chakra、V8和SpiderMonkey将受以上因素的影响，表现出不尽相同又较相似的回收策略，而JScript.dll和Carakan则完全没有这方面的优化，会完全整个LexicalEnvironment中的所有变量绑定，造成一定的内存消耗。\n如果有非常庞大的对象，切预计会在老旧的引擎中执行，则使用闭包时，注意将闭包不需要的对象设置为空引用。\n注释 单行注释// 后跟一个空格 多行注释 /* */ ，尽量避免使用，尽量使用单行注释代替 文档注释 /** */形式 文档注释前必须空一行 注释类型说明\n基本类型使用小写（number, string, (boolean），引用类型使用大写(Object, Function, Array, Date, RegExp\u0026hellip;)\n类型 语法 解释 String {string} Number {number} Boolean {boolean} Object {Object} Function {Function} RegExp {RegExp} Array {Array} Date {Date} 单一类型集合 {Array} 多类型 {number/boolean} 可能时number类型也可能时boolean类型 任意类型 {*} 任意类型 文件注释\n// 文件注释 /** * @file describe the file * @author wjf */ // 命名空间 /** * @namespace */ 类\n/** * 描述 * * @class 类名称 * @extends dev */ 函数注释，方法注释\n/** * 函数描述 * * @param {string} name 参数1 * @param {Object} param 参数2 * @param {string} param.name 参数2描述 * @return {Object} 返回值描述 */ 事件注释\n/** * 事件描述 * * @event select#change * @param {} params */ 模块注释\n/** * module description * * @module * @exports {number} * @exports {string} */ 其他注释标识符\n/** * @file 文件 * @namespace 命名空间 * @module regexp 模块 * @constructor 构造函数声明注释 * @param {string} params 参数注释 * @class 类 * @extends dev 继承 * @overview 对当前代码文件的描述 * @copyright 版权信息 * @author wjf 代码作者信息 * @version 1.2.2 版本信息 * @throws {string} 抛出异常 * @createDate 2019 创建时间 * @example http() 示例展示，使用方法 * @return {string} 返回值 */ ","permalink":"https://xyming108.github.io/posts/jscodespecification/","summary":"前言 本文档的目标是JavaScript代码风格保持一致，容易被理解和被维护。 项目规范 项目必须有 README.md 描述文件 项目描述 引用技术描述 代码风格描述 目录结构 运行环境 开发命令，运行命令，以及其他命令 复杂流程介绍等 代码风格 建议JavaScript使用无BOM的UTF-8编码 建议在文件结尾处保留一","title":"JavaScript开发规范"},{"content":"不知不觉中vue-cli都升级到3.x了，赶快看下文档来学习下\n第一步升级 vue cli 要求node 8+\nnode方面就不在做详细解答。\nnpm install -g @vue/cli # OR yarn global add @vue/cli # 检查版本 vue --version 具体结果就不在展示，直接进入下一步\n创建项目 3.x给出了多种创建项目的方法，\nvue create demo Vue CLI v3.1.0 ? Please pick a preset: (Use arrow keys) \u0026gt; default (babel, eslint) Manually select features 使用上下键进行选择 第一个是默认配置，很适合快速建立项目 第二个是自定义配置项目 默认配置就不再多说了， 这里主要说下自定义配置\nVue CLI v3.1.0 ? Please pick a preset: Manually select features ? Check the features needed for your project: (Press \u0026lt;space\u0026gt; to s? Check the features needed for your project: (*) Babel #转码器，可以将ES6代码转为ES5代码，从而在现有环境执行 ( ) TypeScript #ts语法 ( ) Progressive Web App (PWA) Support #渐进式Web应用程序 (*) Router #vue路由 (*) Vuex #vue的状态管理模式 (*) CSS Pre-processors #CSS 预处理器（如：less、sass） (*) Linter / Formatter #码风格检查和格式化（如：ESlint） ( ) Unit Testing #单元测试（unit tests） ( ) E2E Testing #e2e（end to end） 测试 小伙伴可以根据自己的需要添加模块，我暂且就选用这几个模块了\n? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) Vue-Router 利用了浏览器自身的hash 模式和 history 模式的特性来实现前端路由（通过调用浏览器提供的接口）\nhash 浏览器url址栏 中的 # 符号（如这个 URL：http://www.baidu.com/#/hello，hash 的值为“ #/hello”），hash 不被包括在 HTTP 请求中（对后端完全没有影响），因此改变 hash 不会重新加载页面\nhistory 利用了 HTML5 History Interface 中新增的 pushState( ) 和 replaceState( ) 方法（需要特定浏览器支持）。单页客户端应用，history mode 需要后台配置支持 详细查看：https://router.vuejs.org/zh/guide/essentials/history-mode.html\ncss预处理\n? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys) \u0026gt; Sass/SCSS Less Stylus eslint配置\n? Pick a linter / formatter config: (Use arrow keys) \u0026gt; ESLint with error prevention only // 仅防止错误 ESLint + Airbnb config ESLint + Standard config ESLint + Prettier 何时检测代码\n? Pick additional lint features: (Press \u0026lt;space\u0026gt; to select, \u0026lt;a\u0026gt; to toggle all, \u0026lt;i\u0026gt; to invert selection) (*) Lint on save #保存时检测 ( ) Lint and fix on commit #fix和commit时候检查 单元测试\n? Pick a unit testing solution: (Use arrow keys) Mocha + Chai #mocha灵活,只提供简单的测试结构，如果需要其他功能需要添加其他库/插件完成。必须在全局环境中安装 Jest #安装配置简单，容易上手。内置Istanbul，可以查看到测试覆盖率，相较于Mocha:配置简洁、测试代码简洁、易于和babel集成、内置丰富的expect 配置文件存放位置\n? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys) In dedicated config files #存放到独立文件中 In package.json #存放到webpack.json中 是否保存配置文件\n? Save this as a preset for future projects? (Y/n) #y:记录本次配置，然后需要你起个名; n：不记录本次配置 新建项目结束 项目结构\n|-- public | |-- index.html |-- src // 源码目录 | |-- assets // 静态文件，会被webpack处理 | |-- components // vue公共组件 | |-- views // 视图文件 | |-- store // vuex的状态管理 | |-- router // 路由文件 | |-- App.vue // 页面入口文件 | |-- main.js // 程序入口文件，加载各种公共 | |-- router.js // 路由文件 | |-- store.js // 状态仓库文件 | |-- registerServiceWorker.js |-- tests | |-- e2e | |-- unit |-- .browserslistrc |-- .gitignore // git上传需要忽略的文件格式 |-- .eslintrc.js // eslint配置 |-- babel.config.js // babel配置 |-- postcss.config.js // postcss配置 |-- cypress.json |-- package.json // 项目基本信息 |-- package-lock.json vue ui vue ui完全是可视化的创建项目。 就不在多说了，傻子都能创建出来项目\n","permalink":"https://xyming108.github.io/posts/vue3-1/","summary":"不知不觉中vue-cli都升级到3.x了，赶快看下文档来学习下 第一步升级 vue cli 要求node 8+ node方面就不在做详细解答。 npm install -g @vue/cli # OR yarn global add @vue/cli # 检查版本 vue --version 具体结果就不在展示，直接进入下一步 创建项目 3.x给出了多种创建项目的方法， vue create demo Vue CLI v3.1.0 ? Please pick a preset: (Use arrow keys) \u0026gt; default (babel, eslint) Manually select features 使用上下键","title":"Vue(五) -- vue-cli(3.x)"},{"content":"Promise 简介: Promise 是异步编程的一种解决方案 ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。\nPromise 一般用于网络和 I/O 操作，比如读取文件，或者创建 HTTP 请求。我们可以创建异步 promise，然后用 then 添加一个回调函数，当 promise 结束后会触发这个回调函数，而非阻塞住当前“线程”。回调函数本身也可以返回一个 promise 对象，所以我们能够链式调用 promise。\npromise提供的方法属性\nPromise.prototype.then(); Promise.prototype.catch(); Promise.prototype.finally(); Promise.all(); Promise.race(); Promise.resolve(); Promise.reject(); Promise.reject(); then then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\ncatch catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。\nfinally finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 finally方法的回调函数不接受任何参数\nall Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 all方法接受一个数组作为参数\nconst p = Promise.all([p1, p2, p3]); p .then() .catch(); p是包含 3 个 Promise 实例的数组，只有这 3 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。\nrace Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。\nconst p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\n封装ajax const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(\u0026#34;GET\u0026#34;, url); client.onreadystatechange = handler; client.responseType = \u0026#34;json\u0026#34;; client.setRequestHeader(\u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;); client.send(); }); return promise; }; Async ES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nAsync 是定义返回 promise 对象函数的快捷方法。\nasync如下特点\n有内置执行器，不用调用next Generator函数是需要调用next指令来运行异步的语句，async不需要调用next，直接像运行正常的函数那样运行就可以\n有更好的语义化 语义化更明确，相比较于Generator的*和yield，async和await更明确。\nawait后面可以跟promise或者任意类型的值 yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n返回一个promise对象，可以调用.then async直接返回一个promise对象，可以用then和cache来处理。\n语法\n返回 Promise 对象 async函数返回一个 Promise 对象 async函数内部return语句返回的值，会成为then方法回调函数的参数 async function f() { return \u0026#39;hello world\u0026#39;; } f().then(res =\u0026gt; console.log(res)) // \u0026#34;hello world\u0026#34; async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到 async function f() { throw new Error(\u0026#39;出错了\u0026#39;); } f().then( v =\u0026gt; console.log(res), e =\u0026gt; console.log(err) ) // Error: 出错了 async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数\nawait命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象\nasync function f() { return await \u0026#39;hello word\u0026#39;; } f().then(res =\u0026gt; console.log(res)) // hello word // await命令的参数是数值123，它被转成 Promise 对象，并立即resolve。 async function f() { await Promise.reject(\u0026#39;出错了\u0026#39;); } f() .then(v =\u0026gt; console.log(res)) .catch(e =\u0026gt; console.log(err)) // 出错了 // await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到 async function f() { await Promise.reject(\u0026#39;出错了\u0026#39;); } f() .then(ret =\u0026gt; console.log(ret)) .catch(err =\u0026gt; console.log(err)) // 出错了 // await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的 async function f() { await Promise.reject(\u0026#39;出错了\u0026#39;); await Promise.resolve(\u0026#39;hello world\u0026#39;); // 不会执行 } // 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行 async 错误处理方法\nasync function myFunction() { try { await somethingThatReturnsAPromise(); } catch (err) { console.log(err); } } ","permalink":"https://xyming108.github.io/posts/async/","summary":"Promise 简介: Promise 是异步编程的一种解决方案 ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 Promise 一般用于网络和 I/O 操作，比如读取文件，或者创建 HTTP 请求。我们可以创建异步 promise，然后用 then 添加一个回调函数，当 promise 结束后会触发这个回调函数，而非阻塞住当前“线程”。回调函数本","title":"js异步 -- Promise 与 Async / Await"},{"content":"函数防抖（debounce） 函数防抖是在函数节流的基础上，每隔固定的时间，不管定时器触发没触发，都会执行一遍自定义函数。\n单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成JS就是，事件内的N个动作会变忽略，只有事件后由程序触发的动作只是有效。\n函数防抖的应用场景，最常见的就是用户注册时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。以下还是以页面元素滚动监听的例子，来进行解析：\n以邮箱验证为例\nvar debounce = function () { var run = setTiemout(function () { clearTimeout(run); // 函数体，操作内容 }, 380); } $(\u0026#39;.phone\u0026#39;).chenge(debounce); 优点： 函数防抖的合理应用能够帮助我们充分节省cpu，内存等资源，同时又通过一定的时延间隔去执行自定义函数，在一些频繁的DOM操作，http请求应用中有效提升用户体验。\n函数节流（throttle） 当持续触发事件时，保证一定时间段内只调用一次事件处理函数。\n节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。\n函数节流会用在比input, keyup更频繁触发的事件中，如resize, touchmove, mousemove, scroll。throttle 会强制函数以固定的速率执行。因此这个方法比较适合应用于动画相关的场景。\n咦页面滚动为例\nvar throttle = function () { var time = Date.now(); return function () { var nt = Date.now(); if (nt - time \u0026gt;= 2000) { time = Date.now(); // 函数体2秒执行一次 } } } $(window).scroll(throttle); 优点： 使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。\n优化之路刚刚开始，欢迎继续查阅。 如有问题请联系newwjf@outlook.com\n","permalink":"https://xyming108.github.io/posts/throttle/","summary":"函数防抖（debounce） 函数防抖是在函数节流的基础上，每隔固定的时间，不管定时器触发没触发，都会执行一遍自定义函数。 单反也有相似的概念，在拍照的时候手如果拿不稳晃的时候拍照一般手机是拍不出好照片的，因此智能手机是在你按一下时连续拍许多张， 能过合成手段，生成一张。翻译成JS就是","title":"优化之路-js函数防抖与函数节流"},{"content":"什么是vue组件： 组件（Component）是 Vue.js 最强大的功能之一。 组件可以扩展 HTML 元素，封装可重用的代码。\n下面全部按照分开试写法讲解，分开与不分开写都一样， vue中组件同样具有三部分（template, script, style）组成以.vue结尾文件。\n注册组件 全局注册 全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。\nVue.component(\u0026#34;my-component\u0026#34;,{ template:\u0026#34;\u0026lt;p\u0026gt;test，hi i am a component\u0026lt;/p\u0026gt;\u0026#34; }) 局部注册 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;my-component\u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;index\u0026#39;, components:{ \u0026#39;my-component\u0026#39;: { template:\u0026#39;\u0026lt;p\u0026gt;hello this is part component\u0026lt;/p\u0026gt;\u0026#39; } } \u0026lt;/script\u0026gt; // 组件分离写法 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;my-component\u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import myComponent from \u0026#39;./myComponent\u0026#39;; export default { name: \u0026#39;index\u0026#39;, components:{ \u0026#39;my-component\u0026#39;: myComponent } \u0026lt;/script\u0026gt; 组件传参 下面讲述全部由局部注册为例，全局注册同理。\n父子组件 父子组件的概念这里就不在解释，如有不懂请google.\nprop 向子组件传参 // 父组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;my-component :name=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import myComponent from \u0026#39;./myComponent\u0026#39;; export default { name: \u0026#39;index\u0026#39;, data: () { return { name: \u0026#39;父子传参\u0026#39; } }, components:{ \u0026#39;my-component\u0026#39;: myComponent } \u0026lt;/script\u0026gt; // 子组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; {{name}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;sub\u0026#39;, data: () { return {} }, props: [\u0026#39;name\u0026#39;] // props 可以为数组，可以为对象，如下： // 下面为第二种形式，对象写法 props: { name: String, // 只进行类型检测 age: { type: Number, // 类型 default: 0, // 默认值 required: true, // 必传 // 检验方法 validator: function (value) { return value \u0026gt;= 0 } } } \u0026lt;/script\u0026gt; $emit 向父组件传参 // 子组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;convey\u0026#34;\u0026gt;点击向父组件传参\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;sub\u0026#39;, data: () { return {} }, methods: { convey: function () { this.$emit(\u0026#39;parentEvent\u0026#39;, \u0026#39;子组件数据\u0026#39;); } } \u0026lt;/script\u0026gt; // 父组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 接受子组件参数方法事件 --\u0026gt; \u0026lt;my-component @parentEvent=\u0026#34;receive\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import myComponent from \u0026#39;./myComponent\u0026#39;; export default { name: \u0026#39;index\u0026#39;, data: () { return { child: \u0026#39;\u0026#39; } }, methods: { receive: function (data) { this.child = data; } } components:{ \u0026#39;my-component\u0026#39;: myComponent } \u0026lt;/script\u0026gt; 事件总线 上面讲到了父子间的消息互动，那平级之家怎么互动的，下面将来用vue的事件总线完成平级之间的互动.\n一、 创建事件总线 src/assets/下创建一个eventBus.js,\nimport Vue from \u0026#39;Vue\u0026#39;; export default new Vue(); 二、 分发事件\nimport eventBus from \u0026#39;../assets/eventBus\u0026#39;; export default new Vue({ name: \u0026#39;alert\u0026#39;, mounted: function () { // 添加事件监听，$on(事件名称, 回掉函数) eventBus.$on(\u0026#39;alert\u0026#39;, (data) =\u0026gt; {}); // eventBus.$once(\u0026#39;alert\u0026#39;, (data) =\u0026gt; {}); 只出发一次的事件监听 }, beforeDestroy: function () { // 移除事件监听 eventBus.$off(\u0026#39;alert\u0026#39;, () =\u0026gt; {}); } }) 三、 事件\nimport eventBus from \u0026#39;../assets/eventBus\u0026#39;; export default new Vue({ name: \u0026#39;user\u0026#39;, mounted: function () { // 事件, // 第一个参数是事件名称 // 第二个参数是发送事件所携带的参数 evenBus.$emit(\u0026#39;alert\u0026#39;, {}); } }) 希望这篇文章会对你起到一定作用，如有问题请联系 newwjf@outlook.com/newwjf@163.com\n","permalink":"https://xyming108.github.io/posts/vue-4/","summary":"什么是vue组件： 组件（Component）是 Vue.js 最强大的功能之一。 组件可以扩展 HTML 元素，封装可重用的代码。 下面全部按照分开试写法讲解，分开与不分开写都一样， vue中组件同样具有三部分（template, script, style）组成以.vue结尾文件。 注册组件 全局注册 全局注册的组件可以用在其被","title":"Vue(四) -- 组件"},{"content":"上一篇讲解了vue-cli的使用，这一片讲解vue项目的配置文件，如果还不会vue-cli构建项目的，请先阅读Vue入坑之路(一) \u0026ndash; vue-cli\n文档链接 npm 文档 Vue.js中文文档 Vue-webpack配置文档\nnpm 配置 - package.json package.json json文件不支持注释，请不要在json中注释，\n{ \u0026#34;name\u0026#34;: \u0026#34;vue-demo\u0026#34;, // 项目名称 \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, // 版本 \u0026#34;description\u0026#34;: \u0026#34;A Vue.js project\u0026#34;, // 描述 \u0026#34;author\u0026#34;: \u0026#34;w** \u0026lt;n****a@outlook.com\u0026gt;\u0026#34;, // 作者 \u0026#34;private\u0026#34;: true, // 脚本 \u0026#34;scripts\u0026#34;: { // webpack-dev-server:启动了http服务器，实现实时编译; // inline模式会在webpack.config.js入口配置中新增webpack-dev-server/client?http://localhost:8080/的入口,使得我们访问路径为localhost:8080/index.html（相应的还有另外一种模式Iframe）; // progress:显示打包的进度 \u0026#34;dev\u0026#34;: \u0026#34;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\u0026#34;, //与npm run dev相同，直接运行开发环境 \u0026#34;start\u0026#34;: \u0026#34;npm run dev\u0026#34;, \u0026#34;unit\u0026#34;: \u0026#34;jest --config test/unit/jest.conf.js --coverage\u0026#34;, \u0026#34;e2e\u0026#34;: \u0026#34;node test/e2e/runner.js\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;npm run unit \u0026amp;\u0026amp; npm run e2e\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;eslint --ext .js,.vue src test/unit test/e2e/specs\u0026#34;, //使用node运行build文件 \u0026#34;build\u0026#34;: \u0026#34;node build/build.js\u0026#34; }, // dependencies(项目依赖库):在安装时使用--save则写入到dependencies \u0026#34;dependencies\u0026#34;: { }, // 和devDependencies（开发依赖库）：在安装时使用--save-dev将写入到devDependencies \u0026#34;devDependencies\u0026#34;: { }, // engines是引擎，指定node和npm版本 \u0026#34;engines\u0026#34;: { \u0026#34;node\u0026#34;: \u0026#34;\u0026gt;= 6.0.0\u0026#34;, \u0026#34;npm\u0026#34;: \u0026#34;\u0026gt;= 3.0.0\u0026#34; }, // 限制了浏览器或者客户端需要什么版本才可运行 \u0026#34;browserslist\u0026#34;: [ \u0026#34;\u0026gt; 1%\u0026#34;, \u0026#34;last 2 versions\u0026#34;, \u0026#34;not ie \u0026lt;= 8\u0026#34; ] } npm 脚本 start 命令可以 npm start运行，其他都是npm run \u0026hellip;运行 1.执行npm start 执行了npm run dev命令 2.执行npm run dev命令 执行了webpack-dev-server --inline --progress --config build/webpack.dev.conf.js 3.执行npm run build 执行了build/build.js文件\nvue部分模块介绍 // vue.js \u0026#34;vue\u0026#34;: \u0026#34;^2.5.2\u0026#34;, // vue的路由插件 \u0026#34;vue-router\u0026#34;: \u0026#34;^3.0.1\u0026#34; // autoprefixer作为postcss插件用来解析CSS补充前缀，例如 display: flex会补充为display:-webkit-box;display: -webkit-flex;display: -ms-flexbox;display: flex。 \u0026#34;autoprefixer\u0026#34;: \u0026#34;^7.1.2\u0026#34;, // babel:以下几个babel开头的都是针对es6解析的插件。用最新标准编写的 JavaScript 代码向下编译成可以在今天随处可用的版本 // babel的核心，把 js 代码分析成 ast ，方便各个插件分析语法进行相应的处理。 \u0026#34;babel-core\u0026#34;: \u0026#34;^6.22.1\u0026#34;, // 预制babel-template函数，提供给vue,jsx等使用 \u0026#34;babel-helper-vue-jsx-merge-props\u0026#34;: \u0026#34;^2.0.3\u0026#34;, // 使项目运行使用Babel和webpack来传输js文件，使用babel-core提供的api进行转译 \u0026#34;babel-loader\u0026#34;: \u0026#34;^7.1.1\u0026#34;, // 支持jsx \u0026#34;babel-plugin-syntax-jsx\u0026#34;: \u0026#34;^6.18.0\u0026#34;, // 避免编译输出中的重复，直接编译到build环境中 \u0026#34;babel-plugin-transform-runtime\u0026#34;: \u0026#34;^6.22.0\u0026#34;, // babel转译过程中使用到的插件，避免重复 \u0026#34;babel-plugin-transform-vue-jsx\u0026#34;: \u0026#34;^3.5.0\u0026#34;, // 转为es5，transform阶段使用到的插件之一 \u0026#34;babel-preset-env\u0026#34;: \u0026#34;^1.3.2\u0026#34;, // ECMAScript第二阶段的规范 \u0026#34;babel-preset-stage-2\u0026#34;: \u0026#34;^6.22.0\u0026#34;, // 用来在命令行输出不同颜色文字 \u0026#34;chalk\u0026#34;: \u0026#34;^2.0.1\u0026#34;, // 拷贝资源和文件 \u0026#34;copy-webpack-plugin\u0026#34;: \u0026#34;^4.0.1\u0026#34;, // webpack先用css-loader加载器去解析后缀为css的文件，再使用style-loader生成一个内容为最终解析完的css代码的style标签，放到head标签里 \u0026#34;css-loader\u0026#34;: \u0026#34;^0.28.0\u0026#34;, // 将一个以上的包里面的文本提取到单独文件中 \u0026#34;extract-text-webpack-plugin\u0026#34;: \u0026#34;^3.0.0\u0026#34;, // 打包压缩文件，与url-loader用法类似 \u0026#34;file-loader\u0026#34;: \u0026#34;^1.1.4\u0026#34;, // 识别某些类别的WebPACK错误和清理，聚合和优先排序，以提供更好的开发经验 \u0026#34;friendly-errors-webpack-plugin\u0026#34;: \u0026#34;^1.6.1\u0026#34;, // 简化了HTML文件的创建，引入了外部资源，创建html的入口文件，可通过此项进行多页面的配置 \u0026#34;html-webpack-plugin\u0026#34;: \u0026#34;^2.30.1\u0026#34;, // 支持使用node发送跨平台的本地通知 \u0026#34;node-notifier\u0026#34;: \u0026#34;^5.1.2\u0026#34;, // 压缩提取出的css，并解决ExtractTextPlugin分离出的js重复问题(多个文件引入同一css文件) \u0026#34;optimize-css-assets-webpack-plugin\u0026#34;: \u0026#34;^3.2.0\u0026#34;, // 加载（loading）的插件 \u0026#34;ora\u0026#34;: \u0026#34;^1.2.0\u0026#34;, // 查看进程端口 \u0026#34;portfinder\u0026#34;: \u0026#34;^1.0.13\u0026#34;, // 可以消耗本地文件、节点模块或web_modules \u0026#34;postcss-import\u0026#34;: \u0026#34;^11.0.0\u0026#34;, // 用来兼容css的插件 \u0026#34;postcss-loader\u0026#34;: \u0026#34;^2.0.8\u0026#34;, // URL上重新定位、内联或复制 \u0026#34;postcss-url\u0026#34;: \u0026#34;^7.2.1\u0026#34;, // 节点的UNIX命令RM—RF,强制删除文件或者目录的命令 \u0026#34;rimraf\u0026#34;: \u0026#34;^2.6.0\u0026#34;, // 用来对特定的版本号做判断的 \u0026#34;semver\u0026#34;: \u0026#34;^5.3.0\u0026#34;, // 使用它来消除shell脚本在UNIX上的依赖性，同时仍然保留其熟悉和强大的命令，即可执行Unix系统命令 \u0026#34;shelljs\u0026#34;: \u0026#34;^0.7.6\u0026#34;, // 压缩js文件 \u0026#34;uglifyjs-webpack-plugin\u0026#34;: \u0026#34;^1.1.1\u0026#34;, // 压缩文件，可将图片转化为base64 \u0026#34;url-loader\u0026#34;: \u0026#34;^0.5.8\u0026#34;, // VUE单文件组件的WebPACK加载器 \u0026#34;vue-loader\u0026#34;: \u0026#34;^13.3.0\u0026#34;, // 类似于样式加载程序，您可以在CSS加载器之后将其链接，以将CSS动态地注入到文档中作为样式标签 \u0026#34;vue-style-loader\u0026#34;: \u0026#34;^3.0.1\u0026#34;, // 这个包可以用来预编译VUE模板到渲染函数，以避免运行时编译开销和CSP限制 \u0026#34;vue-template-compiler\u0026#34;: \u0026#34;^2.5.2\u0026#34;, // 打包工具 \u0026#34;webpack\u0026#34;: \u0026#34;^3.6.0\u0026#34;, // 可视化webpack输出文件的大小 \u0026#34;webpack-bundle-analyzer\u0026#34;: \u0026#34;^2.9.0\u0026#34;, // 提供一个提供实时重载的开发服务器 \u0026#34;webpack-dev-server\u0026#34;: \u0026#34;^2.9.1\u0026#34;, // 它将数组和合并对象创建一个新对象。如果遇到函数，它将执行它们，通过算法运行结果，然后再次将返回的值封装在函数中 \u0026#34;webpack-merge\u0026#34;: \u0026#34;^4.1.0\u0026#34; 部分包解释 file-loader和url-loader的区别：以图片为例，file-loader可对图片进行压缩，但是还是通过文件路径进行引入，当http请求增多时会降低页面性能，而url-loader通过设定limit参数，小于limit字节的图片会被转成base64的文件，大于limit字节的将进行图片压缩的操作。总而言之，url-loader是file-loader的上层封装。\n了解更多，请查阅npm配置文档 , 点击查看阅读\nvue 配置 配置文件结构 |-- config // 项目开发环境配置 | |-- dev.env.js // 开发环境变量 | |-- index.js // 项目一些配置变量 | |-- prod.env.js // 生产环境变量 | |-- test.env.js // 测试环境变量 config/index.js config内的文件其实是服务于build的，大部分是定义一个变量export出去。\n// 采用严格模式 \u0026#39;use strict\u0026#39; // 加载路径模块 const path = require(\u0026#39;path\u0026#39;) module.exports = { // 开发环境配置 dev: { // 子目录，一般存放css,js,image等文件 assetsSubDirectory: \u0026#39;static\u0026#39;, // 根目录 assetsPublicPath: \u0026#39;/\u0026#39;, // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式 // 如果需要代理 proxyTable: { \u0026#39;/list\u0026#39;: { target: \u0026#39;http://api.xxx.com\u0026#39;, // 目标url地址 changeOrigin: true, // 指示是否跨域 pathRewrite: { \u0026#39;^/list\u0026#39;: \u0026#39;/list\u0026#39; // 可以使用 /list 等价于 api.xxx.com/list } } }, host: \u0026#39;localhost\u0026#39;, // 主机地址 port: 8080, // 端口 autoOpenBrowser: true, // 自动打开浏览器 errorOverlay: true, // 查询错误 notifyOnErrors: true, // 通知错误 poll: false, // 是跟devserver相关的一个配置，webpack为我们提供的devserver是可以监控文件改动的 useEslint: true, // 开启eslint语法检测 showEslintErrorsInOverlay: false, // 是否展示eslint的错误提示 devtool: \u0026#39;cheap-module-eval-source-map\u0026#39;, // webpack提供的用来方便调试的配置，它有四种模式，可以查看webpack文档了解更多 cacheBusting: true, // 一个配合devtool的配置，当给文件名插入新的hash导致清楚缓存时是否生成souce maps，默认在开发环境下为true cssSourceMap: true // 是否开启cssSourceMap }, // 下面是build也就是生产编译环境下的一些配置 build: { // 下面是相对路径的拼接，假如当前跟目录是config，那么下面配置的index属性的属性值就是dist/index.html index: path.resolve(__dirname, \u0026#39;../dist/index.html\u0026#39;), // 是静态资源的根目录 也就是dist目录 assetsRoot: path.resolve(__dirname, \u0026#39;../dist\u0026#39;), // 定义的是静态资源根目录的子目录static，也就是dist目录下面的static assetsSubDirectory: \u0026#39;static\u0026#39;, // 定义的是静态资源的公开路径，也就是真正的引用路径 assetsPublicPath: \u0026#39;/\u0026#39;, // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现 productionSourceMap: true, devtool: \u0026#39;#source-map\u0026#39;, // 同上devtool // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin productionGzip: false, // 下面定义要压缩哪些类型的文件 productionGzipExtensions: [\u0026#39;js\u0026#39;, \u0026#39;css\u0026#39;], // 是否开启打包后的分析报告 bundleAnalyzerReport: process.env.npm_config_report } } config/dev.env.js \u0026#39;use strict\u0026#39; // 采用严格模式, 下面将不在说明 const merge = require(\u0026#39;webpack-merge\u0026#39;) const prodEnv = require(\u0026#39;./prod.env\u0026#39;) module.exports = merge(prodEnv, { NODE_ENV: \u0026#39;\u0026#34;development\u0026#34;\u0026#39; }) // webpack-merge提供了一个合并函数，它将数组和合并对象创建一个新对象。 // 如果遇到函数，它将执行它们，通过算法运行结果，然后再次将返回的值封装在函数中.这边将dev和prod进行合并 config/prod.env.js // 当开发是调取dev.env.js的开发环境配置，发布时调用prod.env.js的生产环境配置。 \u0026#39;use strict\u0026#39; module.exports = { NODE_ENV: \u0026#39;\u0026#34;production\u0026#34;\u0026#39; } webpack 配置 配置文件结构 |-- build // 项目构建(webpack)相关代码 | |-- build.js // 生产环境构建代码 | |-- check-version.js // 检查node、npm等版本 | |-- dev-client.js // --热重载相关---新版本没有此文件 | |-- dev-server.js // --构建本地服务器---新版本没有此文件 | |-- utils.js // 构建工具相关 | |-- vue-loader.conf.js // 处理vue文件的配置文件 | |-- webpack.base.conf.js // webpack基础配置 | |-- webpack.dev.conf.js // webpack开发环境配置 | |-- webpack.prod.conf.js // webpack生产环境配置 /build/build.js 该文件作用，即构建生产版本。package.json中的scripts的build就是node build/build.js，输入命令行npm run build对该文件进行编译生成生产环境的代码\n\u0026#39;use strict\u0026#39; require(\u0026#39;./check-versions\u0026#39;)() // 调用检查版本的文件。加（）代表直接调用该函数 process.env.NODE_ENV = \u0026#39;production\u0026#39; // 设置当前是生产环境 const ora = require(\u0026#39;ora\u0026#39;) // 加载动画 const rm = require(\u0026#39;rimraf\u0026#39;) // 删除文件 const path = require(\u0026#39;path\u0026#39;) const chalk = require(\u0026#39;chalk\u0026#39;) // 对文案输出的一个彩色设置 const webpack = require(\u0026#39;webpack\u0026#39;) const config = require(\u0026#39;../config\u0026#39;) // 默认读取下面的config/index.js文件 const webpackConfig = require(\u0026#39;./webpack.prod.conf\u0026#39;) const spinner = ora(\u0026#39;building for production...\u0026#39;) spinner.start() // 先删除dist文件再生成新文件，因为有时候会使用hash来命名，删除整个文件可避免冗余 rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =\u0026gt; { if (err) throw err webpack(webpackConfig, (err, stats) =\u0026gt; { spinner.stop() if (err) throw err process.stdout.write(stats.toString({ colors: true, modules: false, children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build. chunks: false, chunkModules: false }) + \u0026#39;\\n\\n\u0026#39;) if (stats.hasErrors()) { console.log(chalk.red(\u0026#39; Build failed with errors.\\n\u0026#39;)) process.exit(1) } console.log(chalk.cyan(\u0026#39; Build complete.\\n\u0026#39;)) console.log(chalk.yellow( \u0026#39; Tip: built files are meant to be served over an HTTP server.\\n\u0026#39; + \u0026#39; Opening index.html over file:// won\\\u0026#39;t work.\\n\u0026#39; )) }) }) /build/webpack.base.conf.js 基础配置文件\n配置编译入口和输出路径 模块resolve的规则 配置不同类型模块的处理规则 \u0026#39;use strict\u0026#39; const path = require(\u0026#39;path\u0026#39;) // 主要用来处理css-loader和vue-style-loader const utils = require(\u0026#39;./utils\u0026#39;) // 获取config/index.js中的默认配置，config后面没有配置项会自动找index.js const config = require(\u0026#39;../config\u0026#39;) // 主要用来处理各种文件的配置 const vueLoaderConfig = require(\u0026#39;./vue-loader.conf\u0026#39;) // 给出正确的绝对路径 function resolve (dir) { return path.join(__dirname, \u0026#39;..\u0026#39;, dir) } // 对src和test文件夹下的.js和.vue文件使用eslint-loader const createLintingRule = () =\u0026gt; ({ test: /\\.(js|vue)$/, // js,vue文件后缀的 loader: \u0026#39;eslint-loader\u0026#39;, // 使用eslint-loader处理 enforce: \u0026#39;pre\u0026#39;, include: [resolve(\u0026#39;src\u0026#39;), resolve(\u0026#39;test\u0026#39;)], // 包含src和test的文件夹 // options是对vue-loader做的额外选项配置 文件配置在 ./vue-loader.conf 内可以查看代码 options: { formatter: require(\u0026#39;eslint-friendly-formatter\u0026#39;), emitWarning: !config.dev.showEslintErrorsInOverlay } }) module.exports = { context: path.resolve(__dirname, \u0026#39;../\u0026#39;), // 配置webpack编译入口 entry: { app: \u0026#39;./src/main.js\u0026#39; }, // 配置webpack输出路径和命名规则 output: { // webpack输出的目标文件夹路径（例如：/dist） path: config.build.assetsRoot, // webpack输出bundle文件命名格式 filename: \u0026#39;[name].js\u0026#39;, // webpack编译输出的发布路径 publicPath: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? config.build.assetsPublicPath : config.dev.assetsPublicPath }, // 配置模块resolve的规则 resolve: { // 自动解析确定的扩展名，导入模块时不带扩展名 extensions: [\u0026#39;.js\u0026#39;, \u0026#39;.vue\u0026#39;, \u0026#39;.json\u0026#39;], // 创建import 或 require的别名 /* 比如如下文件 src components a.vue router home index.vue 在index.vue里面，正常引用A组件；如下： import A from \u0026#39;../../components/a.vue\u0026#39;; 如果设置了 alias后，那么引用的地方可以如下这样了 import A from \u0026#39;@/components/a.vue\u0026#39;; 注意：这里的 @ 起到了 resolve(\u0026#39;src\u0026#39;)路径的作用了。 */ alias: { \u0026#39;vue$\u0026#39;: \u0026#39;vue/dist/vue.esm.js\u0026#39;, \u0026#39;@\u0026#39;: resolve(\u0026#39;src\u0026#39;), } }, // 配置不同类型模块的处理规则 module: { rules: [ // 在开发环境下 对于以.js或.vue后缀结尾的文件(在src目录下或test目录下的文件)，使用eslint进行文件语法检测。 ...(config.dev.useEslint ? [createLintingRule()] : []), // 对src和test文件夹下的.vue文件使用vue-loader { test: /\\.vue$/, loader: \u0026#39;vue-loader\u0026#39;, options: vueLoaderConfig }, // 对src和test文件夹下的.js文件使用eslint-loader { test: /\\.js$/, loader: \u0026#39;babel-loader\u0026#39;, include: [resolve(\u0026#39;src\u0026#39;), resolve(\u0026#39;test\u0026#39;), resolve(\u0026#39;node_modules/webpack-dev-server/client\u0026#39;)] }, { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: \u0026#39;url-loader\u0026#39;, options: { limit: 10000, // 小于10000字节时的时候处理 // 文件名为name.7位hash的值.扩展名 name: utils.assetsPath(\u0026#39;img/[name].[hash:7].[ext]\u0026#39;) } }, { test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/, loader: \u0026#39;url-loader\u0026#39;, options: { limit: 10000, name: utils.assetsPath(\u0026#39;media/[name].[hash:7].[ext]\u0026#39;) } }, { test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: \u0026#39;url-loader\u0026#39;, options: { limit: 10000, name: utils.assetsPath(\u0026#39;fonts/[name].[hash:7].[ext]\u0026#39;) } } ] }, node: { // prevent webpack from injecting useless setImmediate polyfill because Vue // source contains it (although only uses it if it\u0026#39;s native). setImmediate: false, // prevent webpack from injecting mocks to Node native modules // that does not make sense for the client dgram: \u0026#39;empty\u0026#39;, fs: \u0026#39;empty\u0026#39;, net: \u0026#39;empty\u0026#39;, tls: \u0026#39;empty\u0026#39;, child_process: \u0026#39;empty\u0026#39; } } /build/webpack.dev.conf.js 开发配置文件\n合并基础的webpack配置 使用styleLoaders 配置Source Maps 配置webpack插件 \u0026#39;use strict\u0026#39; const utils = require(\u0026#39;./utils\u0026#39;) const webpack = require(\u0026#39;webpack\u0026#39;) const config = require(\u0026#39;../config\u0026#39;) // 通过webpack-merge实现webpack.dev.conf.js对wepack.base.config.js的继承 const merge = require(\u0026#39;webpack-merge\u0026#39;) const path = require(\u0026#39;path\u0026#39;) const baseWebpackConfig = require(\u0026#39;./webpack.base.conf\u0026#39;) const CopyWebpackPlugin = require(\u0026#39;copy-webpack-plugin\u0026#39;) const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;) const FriendlyErrorsPlugin = require(\u0026#39;friendly-errors-webpack-plugin\u0026#39;) const portfinder = require(\u0026#39;portfinder\u0026#39;) // processs为node的一个全局对象获取当前程序的环境变量，即host const HOST = process.env.HOST const PORT = process.env.PORT \u0026amp;\u0026amp; Number(process.env.PORT) const devWebpackConfig = merge(baseWebpackConfig, { module: { // 规则是工具utils中处理出来的styleLoaders，生成了css，less,postcss等规则 rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true }) }, // cheap-module-eval-source-map is faster for development devtool: config.dev.devtool, // 增强调试 // 此处的配置都是在config的index.js中设定好了 devServer: { // 控制台显示的选项有none, error, warning 或者 info clientLogLevel: \u0026#39;warning\u0026#39;, // 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html historyApiFallback: { rewrites: [ { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, \u0026#39;index.html\u0026#39;) }, ], }, hot: true, // 热加载 contentBase: false, // since we use CopyWebpackPlugin. compress: true, // 压缩 host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, // 调试时自动打开浏览器 overlay: config.dev.errorOverlay ? { warnings: false, errors: true } : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, // 接口代理 quiet: true, // 控制台是否禁止打印警告和错误,若用FriendlyErrorsPlugin 此处为 true watchOptions: { poll: config.dev.poll, // 文件系统检测改动 } }, plugins: [ new webpack.DefinePlugin({ \u0026#39;process.env\u0026#39;: require(\u0026#39;../config/dev.env\u0026#39;) }), new webpack.HotModuleReplacementPlugin(), // 模块热替换插件，修改模块时不需要刷新页面 new webpack.NamedModulesPlugin(), // 显示文件的正确名字 new webpack.NoEmitOnErrorsPlugin(), // 当webpack编译错误的时候，来中端打包进程，防止错误代码打包到文件中 // https://github.com/ampedandwired/html-webpack-plugin // 该插件可自动生成一个 html5 文件或使用模板文件将编译好的代码注入进去 new HtmlWebpackPlugin({ filename: \u0026#39;index.html\u0026#39;, template: \u0026#39;index.html\u0026#39;, inject: true }), // 复制插件 new CopyWebpackPlugin([ { from: path.resolve(__dirname, \u0026#39;../static\u0026#39;), to: config.dev.assetsSubDirectory, ignore: [\u0026#39;.*\u0026#39;] // 忽略.*的文件 } ]) ] }) module.exports = new Promise((resolve, reject) =\u0026gt; { portfinder.basePort = process.env.PORT || config.dev.port // 查找端口号 portfinder.getPort((err, port) =\u0026gt; { if (err) { reject(err) } else { // 端口被占用时就重新设置evn和devServer的端口 process.env.PORT = port // add port to devServer config devWebpackConfig.devServer.port = port // 友好地输出信息 devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({ compilationSuccessInfo: { messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`], }, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined })) resolve(devWebpackConfig) } }) }) /build/webpack.prod.conf.js 合并基础的webpack配置 配置webpack的输出 配置webpack插件 配置gzip模式 配置webpack-bundle-analyzer，分析打包后生成的文件结构 \u0026#39;use strict\u0026#39; const path = require(\u0026#39;path\u0026#39;) const utils = require(\u0026#39;./utils\u0026#39;) const webpack = require(\u0026#39;webpack\u0026#39;) const config = require(\u0026#39;../config\u0026#39;) const merge = require(\u0026#39;webpack-merge\u0026#39;) const baseWebpackConfig = require(\u0026#39;./webpack.base.conf\u0026#39;) const CopyWebpackPlugin = require(\u0026#39;copy-webpack-plugin\u0026#39;) const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;) const ExtractTextPlugin = require(\u0026#39;extract-text-webpack-plugin\u0026#39;) const OptimizeCSSPlugin = require(\u0026#39;optimize-css-assets-webpack-plugin\u0026#39;) const UglifyJsPlugin = require(\u0026#39;uglifyjs-webpack-plugin\u0026#39;) const env = process.env.NODE_ENV === \u0026#39;testing\u0026#39; ? require(\u0026#39;../config/test.env\u0026#39;) : require(\u0026#39;../config/prod.env\u0026#39;) const webpackConfig = merge(baseWebpackConfig, { module: { // 调用utils.styleLoaders的方法 rules: utils.styleLoaders({ // 开启调试的模式。默认为true sourceMap: config.build.productionSourceMap, extract: true, usePostCSS: true }) }, devtool: config.build.productionSourceMap ? config.build.devtool : false, output: { path: config.build.assetsRoot, filename: utils.assetsPath(\u0026#39;js/[name].[chunkhash].js\u0026#39;), chunkFilename: utils.assetsPath(\u0026#39;js/[id].[chunkhash].js\u0026#39;) }, plugins: [ // http://vuejs.github.io/vue-loader/en/workflow/production.html new webpack.DefinePlugin({ \u0026#39;process.env\u0026#39;: env }), new UglifyJsPlugin({ // 压缩 uglifyOptions: { compress: { // 警告：true保留警告，false不保留 warnings: false } }, sourceMap: config.build.productionSourceMap, parallel: true }), // 抽取文本。比如打包之后的index页面有style插入，就是这个插件抽取出来的，减少请求 new ExtractTextPlugin({ filename: utils.assetsPath(\u0026#39;css/[name].[contenthash].css\u0026#39;), // Setting the following option to `false` will not extract CSS from codesplit chunks. // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack. // It\u0026#39;s currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it\u0026#39;s `false`, // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110 allChunks: true, }), // Compress extracted CSS. We are using this plugin so that possible // duplicated CSS from different components can be deduped. // 优化css的插件 new OptimizeCSSPlugin({ cssProcessorOptions: config.build.productionSourceMap ? { safe: true, map: { inline: false } } : { safe: true } }), // generate dist index.html with correct asset hash for caching. // you can customize output by editing /index.html // see https://github.com/ampedandwired/html-webpack-plugin // html打包 new HtmlWebpackPlugin({ filename: process.env.NODE_ENV === \u0026#39;testing\u0026#39; ? \u0026#39;index.html\u0026#39; : config.build.index, template: \u0026#39;index.html\u0026#39;, inject: true, // 压缩 minify: { // 删除注释 removeComments: true, // 删除空格 collapseWhitespace: true, // 删除属性的引号 removeAttributeQuotes: true // more options: // https://github.com/kangax/html-minifier#options-quick-reference }, // 模块排序，按照我们需要的顺序排序 chunksSortMode: \u0026#39;dependency\u0026#39; }), // keep module.id stable when vendor modules does not change new webpack.HashedModuleIdsPlugin(), // enable scope hoisting new webpack.optimize.ModuleConcatenationPlugin(), // 抽取公共的模块 new webpack.optimize.CommonsChunkPlugin({ name: \u0026#39;vendor\u0026#39;, minChunks (module) { // any required modules inside node_modules are extracted to vendor return ( module.resource \u0026amp;\u0026amp; /\\.js$/.test(module.resource) \u0026amp;\u0026amp; module.resource.indexOf( path.join(__dirname, \u0026#39;../node_modules\u0026#39;) ) === 0 ) } }), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated new webpack.optimize.CommonsChunkPlugin({ name: \u0026#39;manifest\u0026#39;, minChunks: Infinity }), // This instance extracts shared chunks from code splitted chunks and bundles them // in a separate chunk, similar to the vendor chunk // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk new webpack.optimize.CommonsChunkPlugin({ name: \u0026#39;app\u0026#39;, async: \u0026#39;vendor-async\u0026#39;, children: true, minChunks: 3 }), // 复制，比如打包完之后需要把打包的文件复制到dist里面 new CopyWebpackPlugin([ { from: path.resolve(__dirname, \u0026#39;../static\u0026#39;), to: config.build.assetsSubDirectory, ignore: [\u0026#39;.*\u0026#39;] } ]) ] }) if (config.build.productionGzip) { const CompressionWebpackPlugin = require(\u0026#39;compression-webpack-plugin\u0026#39;) webpackConfig.plugins.push( new CompressionWebpackPlugin({ asset: \u0026#39;[path].gz[query]\u0026#39;, algorithm: \u0026#39;gzip\u0026#39;, test: new RegExp( \u0026#39;\\\\.(\u0026#39; + config.build.productionGzipExtensions.join(\u0026#39;|\u0026#39;) + \u0026#39;)$\u0026#39; ), threshold: 10240, minRatio: 0.8 }) ) } if (config.build.bundleAnalyzerReport) { const BundleAnalyzerPlugin = require(\u0026#39;webpack-bundle-analyzer\u0026#39;).BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin()) } module.exports = webpackConfig /build/utils.js utils是工具 用来处理css的文件。 \u0026#39;use strict\u0026#39; const path = require(\u0026#39;path\u0026#39;) const config = require(\u0026#39;../config\u0026#39;) // 引入extract-text-webpack-plugin插件，用来将css提取到单独的css文件中 const ExtractTextPlugin = require(\u0026#39;extract-text-webpack-plugin\u0026#39;) const packageConfig = require(\u0026#39;../package.json\u0026#39;) // 导出assetsPath函数，调试和构建时导出文件的路径都采用这种方式的路径 // 根据环境判断开发环境和生产环境，为config文件中index.js文件中定义的build.assetsSubDirectory或dev.assetsSubDirectory exports.assetsPath = function (_path) { const assetsSubDirectory = process.env.NODE_ENV === \u0026#39;production\u0026#39; ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory // path.join和path.posix.join的区别就是，后者以 posix 兼容的方式交互 return path.posix.join(assetsSubDirectory, _path) } // 导出最终读取和导入的loader，来处理对应类型的文件 exports.cssLoaders = function (options) { options = options || {} // 基础的css-loader配置 // 使用了css-loader和postcssLoader，通过options.usePostCSS属性来判断是否使用postcssLoader中压缩等方法 const cssLoader = { loader: \u0026#39;css-loader\u0026#39;, options: { sourceMap: options.sourceMap } } const postcssLoader = { loader: \u0026#39;postcss-loader\u0026#39;, options: { sourceMap: options.sourceMap } } // generate loader string to be used with extract text plugin function generateLoaders (loader, loaderOptions) { // 将上面的基础cssLoader配置放在一个数组里面 const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader] // 加载对应的loader if (loader) { loaders.push({ loader: loader + \u0026#39;-loader\u0026#39;, // Object.assign是es6的方法，主要用来合并对象的，浅拷贝 options: Object.assign({}, loaderOptions, { sourceMap: options.sourceMap }) }) } // Extract CSS when that option is specified // (which is the case during production build) if (options.extract) { // ExtractTextPlugin可提取出文本，代表首先使用上面处理的loaders，当未能正确引入时使用vue-style-loader return ExtractTextPlugin.extract({ use: loaders, fallback: \u0026#39;vue-style-loader\u0026#39; }) } else { // 返回vue-style-loader连接loaders的最终值 return [\u0026#39;vue-style-loader\u0026#39;].concat(loaders) } } // https://vue-loader.vuejs.org/en/configurations/extract-css.html return { // 需要css-loader 和 vue-style-loader css: generateLoaders(), // 需要css-loader和postcssLoader 和 vue-style-loader postcss: generateLoaders(), // 需要less-loader 和 vue-style-loader less: generateLoaders(\u0026#39;less\u0026#39;), // 需要sass-loader 和 vue-style-loader sass: generateLoaders(\u0026#39;sass\u0026#39;, { indentedSyntax: true }), // 需要sass-loader 和 vue-style-loader scss: generateLoaders(\u0026#39;sass\u0026#39;), // 需要stylus-loader 和 vue-style-loader stylus: generateLoaders(\u0026#39;stylus\u0026#39;), // 需要stylus-loader 和 vue-style-loader styl: generateLoaders(\u0026#39;stylus\u0026#39;) } } // Generate loaders for standalone style files (outside of .vue) exports.styleLoaders = function (options) { const output = [] const loaders = exports.cssLoaders(options) // 将各种css,less,sass等综合在一起得出结果输出output for (const extension in loaders) { const loader = loaders[extension] output.push({ test: new RegExp(\u0026#39;\\\\.\u0026#39; + extension + \u0026#39;$\u0026#39;), use: loader }) } return output } exports.createNotifierCallback = () =\u0026gt; { // 发送跨平台通知系统 const notifier = require(\u0026#39;node-notifier\u0026#39;) return (severity, errors) =\u0026gt; { if (severity !== \u0026#39;error\u0026#39;) return // 当报错时输出错误信息的标题，错误信息详情，副标题以及图标 const error = errors[0] const filename = error.file \u0026amp;\u0026amp; error.file.split(\u0026#39;!\u0026#39;).pop() notifier.notify({ title: packageConfig.name, message: severity + \u0026#39;: \u0026#39; + error.name, subtitle: filename || \u0026#39;\u0026#39;, icon: path.join(__dirname, \u0026#39;logo.png\u0026#39;) }) } } /build/vue-loader.conf.js 主要作用就是处理.vue文件 解析这个文件中的每个语言块（template、script、style),转换成js可用的js模块。 \u0026#39;use strict\u0026#39; const utils = require(\u0026#39;./utils\u0026#39;) const config = require(\u0026#39;../config\u0026#39;) const isProduction = process.env.NODE_ENV === \u0026#39;production\u0026#39; const sourceMapEnabled = isProduction ? config.build.productionSourceMap : config.dev.cssSourceMap // 处理项目中的css文件，生产环境和测试环境默认是打开sourceMap // 而extract中的提取样式到单独文件只有在生产环境中才需要 module.exports = { loaders: utils.cssLoaders({ sourceMap: sourceMapEnabled, extract: isProduction }), cssSourceMap: sourceMapEnabled, cacheBusting: config.dev.cacheBusting, // 在模版编译过程中，编译器可以将某些属性 // 如 src 路径，转换为require调用，以便目标资源可以由 webpack 处理. transformToRequire: { video: [\u0026#39;src\u0026#39;, \u0026#39;poster\u0026#39;], source: \u0026#39;src\u0026#39;, img: \u0026#39;src\u0026#39;, image: \u0026#39;xlink:href\u0026#39; } } /build/check-version.js 用于检测node和npm的版本，实现版本依赖 此文件就不在多说了 文章就写到这里了，希望对大家有所帮助，如有不足欢迎指出 邮箱 newwjf@163.com\n","permalink":"https://xyming108.github.io/posts/vue-config/","summary":"上一篇讲解了vue-cli的使用，这一片讲解vue项目的配置文件，如果还不会vue-cli构建项目的，请先阅读Vue入坑之路(一) \u0026ndash; vue-cli 文档链接 npm 文档 Vue.js中文文档 Vue-webpack配置文档 npm 配置 - package.json package.json json文件不支持注释，请不要在json中注释， { \u0026#34;name\u0026#34;: \u0026#34;vue-demo\u0026#34;, // 项目名称 \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, //","title":"Vue(二) -- 项目配置"},{"content":"简介 ECMAScript 6.0 (简称ES6) ，ES6 的第一个版本，在 2015 年 6 月发布，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。\n参考 阮一峰 《ECMAScript 6 入门》\n站点目录 1. let/const 2. 字符串 3. 函数 4. 类class基本用法 5. export,import\nlet/const ES6 中新增加了 let 和 const 两个命令，let用于定义变量，const 用于定义常量, 与var的不同之处在于let，const都是块级作用域，具体请看代码\nlet or var // var if (true) { var test = \u0026#39;hello word\u0026#39;; } console.log(test); // hello word; // let if (true) { let test = \u0026#39;hello word\u0026#39;; } console.log(test); // ReferenceError: test is not defined const // 情况一 const test = {a: 1}; test.a = 2; console.log(test); // {a: 2} // 情况二 const test = \u0026#39;hello word\u0026#39;; test = \u0026#39;test\u0026#39;; // TypeError: Assignment to constant variable. 小伙伴们看到这里是不是感觉不可思议，const是定义常量的（常量就是定义过后不可改变的量），不要急，看我慢慢道来， 原因是对于对象型的使用是指针式引用，常量只是指向了对象的指针，对象的内容却已然可以修改，注意数组（array）也是对象，看代码：\nlet arr = [1, 2, 3, 4]; console.log(typeof arr); // object 那问题来了，怎么判断数组呢，解决这个问题前先了解下js的类型， js中有六种数据类型，包括五种基本数据类型（Number, String, Boolean, Undefined, Null）,和一种复杂数据类型（Object）,如果对js类型比较模糊，请先学习js基础知识。 回到正题，数组类型判断.\nlet arr = [1, 2, 3]; console.log(arr instanceof Array); // true console.log(Array.isArray(arr)); // true 字符串 模板字符串 ( `` ) 反引号来定义模板字符串，\n// es5 var msg = \u0026#39;hello word\u0026#39;; var str1 = \u0026#39;\u0026lt;div\u0026gt;\u0026#39; + msg + \u0026#39;\u0026lt;/div\u0026gt;\u0026#39;; var str2 = \u0026#39;\u0026lt;div\u0026gt;\u0026#39; + \u0026#39;\u0026lt;span\u0026gt;\u0026#39; + \u0026#39;\u0026lt;/span\u0026gt;\u0026#39; + \u0026#39;\u0026lt;/div\u0026gt;\u0026#39;; var str3 = \u0026#39;\u0026lt;div\u0026gt;\\ \u0026lt;span\u0026gt;\\ \u0026lt;/span\u0026gt;\\ \u0026lt;/div\u0026gt;\u0026#39;; // es6 var str1 = `\u0026lt;div\u0026gt;${msg}\u0026lt;/div\u0026gt;`; var str2 = `\u0026lt;div\u0026gt; \u0026lt;span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; `; 注意\n如果在模板字符串中需要使用反引号，则前面要用反斜杠转义 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 模板字符串中嵌入变量，需要将变量名写在${}之中。 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 如果模板字符串中的变量没有声明，将报错。 函数 箭头函数 基本用法 var test = v =\u0026gt; v; // 等同于 var test = function (v) { return v; }; // var test = () =\u0026gt; 5; // 等同于 var test = function () { return 5 }; // var sum = (num1, num2) =\u0026gt; num1 + num2; // 等同于 var sum = function(num1, num2) { return num1 + num2; }; // 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 var sum = (num1, num2) =\u0026gt; { return num1 + num2; } 注意点 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。\n函数参数，参数默认值 ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\n// es6之前 function log (x, y) { x = x || 1; y = y || 2; return x + y; } log(); // 3 log(2,3) // 5 // es6 function log (x = 1, y = 2) { return x + y; } // 或者 let log = (x = 1, y = 2) =\u0026gt; x + y; log(); // 3 log(2,3) // 5 注意\n使用参数默认值时，函数不能有同名参数。 参数变量是默认声明的，所以不能用let或const再次声明。 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 函数参数\n// es6之前 function sum () { var s = 0; for (var i in arguments) { s += arguments[i] } console.log(s); } sum(1,2,3,4,5,6); // 21 // es6 function sum (...num) { var s = 0; for (var i in num) { s += num[i]; } console.log(s); } sum(1,2,3,4,5,6); // 21 注意\narguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。 rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 函数的length属性，不包括 rest 参数。 只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 class基本用法 基本用法 ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。\n基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。\n// 基本使用 class Point { // 类方法 toString () {} } typeof Point; // function 类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。\n// 类的两种方法 class Foo { // ... } const f = new Point(); // Uncaught ReferenceError: Foo is not defined(...) var Point = class { // ... } const f = new Point(); // 正确 类声明和函数声明不同的一点是，函数声明存在变量提升现象，而类声明不会。即，类必须先声明，然后才能使用，否则会抛出ReferenceError异常。\n严格模式 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。\nconstructor constructor方法是一个特殊的类方法，它既不是静态方法也不是实例方法，它仅在实例化的时候被调用。一个类只能拥有一个名为constructor的方法，否则会抛出SyntaxError异常.\n如果没有定义constructor方法，这个方法会被默认添加，即，不管有没有显示定义，任何一个类都有constructor方法。\n子类必须在constructor方法中调用super方法，否则新建实例时会报错。因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象。\n静态方法 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。 如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\n// 静态方法 class Foo { static toString () { console.log(\u0026#39;我是静态方法\u0026#39;); } point () { console.log(\u0026#39;我不是静态方法\u0026#39;); } log () { console.log(\u0026#39;我是输出方法\u0026#39;); } } class Point extends Foo { log () { console.log(\u0026#39;重写父级log方法\u0026#39;); } } let f = new Foo(); let p = new Point(); Foo.toString(); // 我是静态方法 f.toString(); // TypeError: f.toString is not a function f.point(); // 我不是静态方法 f.log(); // 我是输出方法 Point.toString(); // 我是静态方法 p.toString(); // TypeError: p.log is not a function p.point(); // 我不是静态方法 p.log(); // 重写父级log方法 注意\n如果静态方法包含this关键字，这个this指的是类，而不是实例。 静态方法可以与非静态方法重名。 父类的静态方法可以被子类继承。 ES6 明确规定，Class 内部只有静态方法，没有静态属性。 class的getter和setter方法 与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\nclass Point { get prop () { console.log(\u0026#39;我是get方法\u0026#39;); } set prop (value) { console.log(\u0026#39;我是set方法---值为 : \u0026#39; + value); } } let p = new Point(); p.prop; // 我是get方法 p.prop = \u0026#39;demo\u0026#39;; // 我是set方法---值为 : demo 继承 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\nclass Point {} class Foo extends Point {} // Foo就具有Point的所有方法，相当于复制 super super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。\n当做函数使用 class A {} class B extends A { constructor() { super(); //ES6 要求，子类的构造函数必须执行一次super函数。 } } 注意\nsuper虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。\u0026mdash;在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。 只能用在构造函数中； 在构造函数中用this之前，必须先使用super 当做对象使用 class A { c() { return 2; } } class B extends A { constructor() { super(); console.log(super.c()); // 2 } } let b = new B(); 上面代码中，子类B当中的super.c()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.c()就相当于A.prototype.c()。 在普通方法中，指向父类的原型对象；在静态方法中，指向父类。\nimport,export .ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。\n注意\nES6模块默认使用严格模式，无论是否声明“use strict”\nES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。\nexport 模块是独立的文件，该文件内部的所有的变量外部都无法获取。如果希望获取某个变量，必须通过export输出，\n// 方法一 export const a = 1; export const b = 2; export function toString () {} // 方法二 const a = 1; const b = 2; function toString () {} export {a, b, toString}; // 重命名 const a = 1; const b = 2; function toString () {} export { a as v1, b as v2, toString as v3 } export default 使用import导入时，都需要知道模块中所要加载的变量名或函数名，用户可能不想阅读源码，只想直接使用接口，就可以用export default命令，为模块指定输出\nexport default function () {} // 加载时 import toString from \u0026#39;./a.js\u0026#39;; toString(); 注意\nexport 与 export default的区别： 两者都是对外暴露接口，export可以在模块中多次使用，export default只能出现一次。\nimport export定义了模块的对外接口后，其他JS文件就可以通过import来加载这个模块，\n// 方法一 import axios from \u0026#39;./axios\u0026#39;; // 方法二 import {toString, a, b} from \u0026#39;./mo.js\u0026#39;; // 方法三 import {a as b, n as c} from \u0026#39;./mo.js\u0026#39;; // 对方法重命名 import * as reg from \u0026#39;./reg.js\u0026#39;; // 把所有方法放入到reg对象中 es6 基础语法就写到这里了，后续还会介绍es6的Promise 的使用方法等，文章节俭与阮大师的es基础入门，如有问题请联系邮箱newwjf@163.com，我会及时回复。\n","permalink":"https://xyming108.github.io/posts/es6%E5%85%A5%E9%97%A8/","summary":"简介 ECMAScript 6.0 (简称ES6) ，ES6 的第一个版本，在 2015 年 6 月发布，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。 参考 阮一峰 《ECMAScript 6 入门》 站点目录 1. let/const 2. 字符串 3. 函数 4. 类class基本用法 5. export,import let/const ES6 中新增加了 let 和 const 两个命令，let用于定义变量，const 用于","title":"你必须要懂的 ES6 语法"},{"content":"技术的不断发展与革新，最根本的体现于提高用户体验，减少码农们的工作量。\n原生小程序开发相对比较麻烦，不过为了提高代码的复用和模块化同样小程序给我们提供了组价化开发思路。\n小程序中有两种组件化的方式，template，component。 这两者之间的区别是 template主要是展示，方法则需要在调用的页面中定义。 component组件则有自己的业务逻辑，可以看做一个独立的page页面。 简单来说，如果只是展示，使用template就足够了，如果涉及到的业务逻辑交互比较多，那就最好使用component组件了。\n项目结构\n|-- app.js // 小程序逻辑文件 |-- app.json // 小程序公共配置文件 |-- app.wxss // 小程序公共样式文件 |-- images // 存储图片资源 |-- pages // 页面视图 | |-- index // index页面 | |-- index.wxml | |-- index.wxss | |-- index.js | |-- index.json |-- templates //template模板视图 | |-- list.wxml // list模板 |-- components // component组件文件夹 | |-- pop // pop组件文件 | |-- pop.wxml | |-- pop.wxss | |-- pop.js | |-- pop.json 模板（template） 建议创建单独的文件夹template；\ntemplate特点\n只有wxml， wxss 没有json，js等文件 只能数据渲染，不具有逻辑操作能力 \u0026lt;!-- 定义模板 --\u0026gt; \u0026lt;template name=\u0026#34;pop\u0026#34;\u0026gt; \u0026lt;view\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template name=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;view\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; name: 定义模板的名称，调用的时候用到\n调用\n\u0026lt;!-- path: /pages/index/index.wxml --\u0026gt; \u0026lt;!-- 引入模板文件 --\u0026gt; \u0026lt;import src=\u0026#34;/templates/pop\u0026#34;/\u0026gt; \u0026lt;!-- 通过template调用pop模板，通过data传入数据 --\u0026gt; \u0026lt;template is=\u0026#34;pop\u0026#34; data=\u0026#34;{{data}}\u0026#34;/\u0026gt; /* path: /pages/index/index.wxss */ @import \u0026#34;/templates/list/list.wxss\u0026#34;; 模板有自己的作用域，只能通过data出入数据\n组件（component） component组件和普通视图页面一样 同样具有wxml，wxss，js，json文件 与页面不一样的是，Component中的构造函数（也可以称构造器）是Component({})，而页面中的构造函数是Page({})。\nwxml,wxss和page中的wxml，wxss一样，就不在多说\njs文件 小程序通过component构造器来实现\n// path: /components/pop/pop.js Component({ // 对外的属性，父组件传过来的参数存放地方 properties： { name: { type: String, // 变量类型设置 value: \u0026#39;默认值\u0026#39;,// 默认值设置 // 值改变，修改后触发的函数体 observer (newVal, oldVal, changedPath) {} } }, // 组件内部数据，properties，data，共同组成了组件的数据，通过this.data访问 data: { age: 11 }, // 组件监听器,相当于vue中的watch observers: { \u0026#39;name\u0026#39;: function () {} }, // 组件方法存放地方 methods: {}, // 生命周期，组件刚刚创建调用 created: function () {}， // 生命周期,在组件实例进入页面节点树时执行 attached: function () {}, // 生命周期，在组件在视图层布局完成后执行 ready: function () {}, // 生命周期，在组件实例被移动到节点树另一个位置时执行 moved: function () {}, // 生命周期,\t在组件实例被从页面节点树移除时执行 detached: function () {}, // 生命周期,\t每当组件方法抛出错误时执行 // error: function () {} // 组件关系,组件之间联系属性 relations: {}, externalClasses: [], // 其他方法使用相对较少 }) // path: /component/pop/pop.json { \u0026#34;component\u0026#34;: true, \u0026#34;usingComponents\u0026#34;: {} } 组件调用方法\npath: /page/index/index.json\n{ \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;父组件\u0026#34;, \u0026#34;usingComponents\u0026#34;: { \u0026#34;pop\u0026#34;: \u0026#34;../../components/pop/pop\u0026#34; } } path: /page/index/index.wxml\n\u0026lt;pop\\\u0026gt; path: /page/index/index.wxss\n@import \u0026#34;/component/pop/pop.wxss\u0026#34;; 组件联系（传参，响应）\n父传子\n\u0026lt;!-- path: /page/index/index.wxml --\u0026gt; \u0026lt;pop show=\u0026#34;{{show}}\u0026#34; name=\u0026#34;{{name}}\u0026#34; bind:popEvent=\u0026#34;parentEvent\u0026#34;\u0026gt;\u0026lt;/pop\u0026gt; \u0026lt;!-- show: 父组件传给pop的show变量 name: 父组件传给pop的name变量 bind:popEvent=\u0026#34;parentEvent\u0026#34; pop通过触发popEvent事件响应父组件 --\u0026gt; 子响应父\n// path: /component/pop/pop.js Component({ methods: { btnClick: function () { let myEventDetail = {}; // detail对象，提供给事件监听函数 let myEventOption = {}; // 触发事件的选项 this.triggerEvent(\u0026#39;popEvent\u0026#39;, myEventDetail, myEventOption ); // pop通过triggerEvent响应父组件 } } }) ","permalink":"https://xyming108.github.io/posts/wx2/","summary":"技术的不断发展与革新，最根本的体现于提高用户体验，减少码农们的工作量。 原生小程序开发相对比较麻烦，不过为了提高代码的复用和模块化同样小程序给我们提供了组价化开发思路。 小程序中有两种组件化的方式，template，component。 这两者之间的区别是 template主要是展示，方","title":"微信小程序-template / component"}]